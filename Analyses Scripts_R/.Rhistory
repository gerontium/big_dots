theme(axis.title.x = element_text(face="bold", size=14),
axis.text.x  = element_text(face="bold", angle=0,  size=14)) +
theme(axis.title.y = element_text(face="bold", size=14),
axis.text.y  = element_text(angle=0, vjust=0.5, size=14)) +
theme(plot.title = element_text(face="bold", size=16)) +
ggtitle("Forthcoming RT (Right Hemifield)\nPredicted by N2c Amplidude")
ggplot(RightRT_N2c_per_sample, aes(Time, N2c_t_value)) + geom_line(color= "#00BFC4",  size=1.4) +
geom_hline(yintercept=2, alpha = 0.5,  size=1.4) + geom_hline(yintercept=-2, alpha = 0.5,  size=1.4) + geom_vline(xintercept=0, alpha = 0.5,  size=1.4) +
coord_cartesian(ylim = c(-5, 4), xlim = c(-100, 600)) +
theme(axis.title.x = element_text(face="bold", size=14),
axis.text.x  = element_text(face="bold", angle=0,  size=14)) +
theme(axis.title.y = element_text(face="bold", size=14),
axis.text.y  = element_text(angle=0, vjust=0.5, size=14)) +
theme(plot.title = element_text(face="bold", size=16)) +
ggtitle("Forthcoming RT (Right Hemifield)\nPredicted by N2c Amplidude")
per_sample_RightHemifield <- data_Stim_locked_ERP2 %>% filter(., Hemifield=="Right", Time>-100, Time<1000) %>% group_by(Time)
RightRT_N2c_per_sample<-per_sample_RightHemifield %>%  do(N2c_t_value = summary(lmer(log(RT) ~ N2c_CSD_rollmean + (1|ID) + (1|ITI) + (1|MotionDirection), data = ., REML=FALSE, na.action = na.omit))$coefficients[2,3])
RightRT_N2c_per_sample$N2c_t_value<-as.double(RightRT_N2c_per_sample$N2c_t_value)
ggplot(RightRT_N2c_per_sample, aes(Time, N2c_t_value)) + geom_line(color= "#00BFC4",  size=1.4) +
geom_hline(yintercept=2, alpha = 0.5,  size=1.4) + geom_hline(yintercept=-2, alpha = 0.5,  size=1.4) + geom_vline(xintercept=0, alpha = 0.5,  size=1.4) +
coord_cartesian(ylim = c(-5, 4), xlim = c(-100, 600)) +
theme(axis.title.x = element_text(face="bold", size=14),
axis.text.x  = element_text(face="bold", angle=0,  size=14)) +
theme(axis.title.y = element_text(face="bold", size=14),
axis.text.y  = element_text(angle=0, vjust=0.5, size=14)) +
theme(plot.title = element_text(face="bold", size=16)) +
ggtitle("Forthcoming RT (Right Hemifield)\nPredicted by N2c Amplidude")
##Does N2c predict Right Hemifield target reaction time?
per_sample_RightHemifield <- data_Stim_locked_ERP2 %>% filter(., Hemifield=="Right", Time>-100, Time<1000) %>% group_by(Time)
RightRT_N2c_per_sample<-per_sample_RightHemifield %>%  do(N2c_t_value = summary(lmer(log(RT) ~ N2c_CSD_rollmean + (N2c_CSD_rollmean|ID) + (1|ITI) + (1|MotionDirection), data = ., REML=FALSE, na.action = na.omit))$coefficients[2,3])
##Does N2c predict Left Hemifield target reaction time?
per_sample_LeftHemifield <- data_Stim_locked_ERP2 %>% filter(., Hemifield=="Left", Time>-100, Time<1000) %>% group_by(Time)
LeftRT_N2c_per_sample<-per_sample_LeftHemifield %>%  do(N2c_t_value = summary(lmer(log(RT) ~ N2c_CSD_rollmean + (N2c_CSD_rollmean|ID) + (1|ITI) + (1|MotionDirection), data = ., REML=FALSE, na.action = na.omit))$coefficients[2,3])
##Does N2c predict Right Hemifield target reaction time?
per_sample_RightHemifield <- data_Stim_locked_ERP2 %>% filter(., Hemifield=="Right", Time>-100, Time<1000) %>% group_by(Time)
RightRT_N2c_per_sample<-per_sample_RightHemifield %>%  do(N2c_t_value = summary(lmer(log(RT) ~ N2c_CSD_rollmean + (N2c_CSD_rollmean|ID) + (1|ITI) + (1|MotionDirection), data = ., REML=FALSE, na.action = na.omit))$coefficients[2,3])
RightRT_N2c_per_sample$N2c_t_value<-as.double(RightRT_N2c_per_sample$N2c_t_value)
ggplot(RightRT_N2c_per_sample, aes(Time, N2c_t_value)) + geom_line(color= "#00BFC4",  size=1.4) +
geom_hline(yintercept=2, alpha = 0.5,  size=1.4) + geom_hline(yintercept=-2, alpha = 0.5,  size=1.4) + geom_vline(xintercept=0, alpha = 0.5,  size=1.4) +
coord_cartesian(ylim = c(-5, 4), xlim = c(-100, 600)) +
theme(axis.title.x = element_text(face="bold", size=14),
axis.text.x  = element_text(face="bold", angle=0,  size=14)) +
theme(axis.title.y = element_text(face="bold", size=14),
axis.text.y  = element_text(angle=0, vjust=0.5, size=14)) +
theme(plot.title = element_text(face="bold", size=16)) +
ggtitle("Forthcoming RT (Right Hemifield)\nPredicted by N2c Amplidude")
##Does N2c predict Left Hemifield target reaction time?
per_sample_LeftHemifield <- data_Stim_locked_ERP2 %>% filter(., Hemifield=="Left", Time>-100, Time<1000) %>% group_by(Time)
LeftRT_N2c_per_sample<-per_sample_LeftHemifield %>%  do(N2c_t_value = summary(lmer(log(RT) ~ N2c_CSD_rollmean + (N2c_CSD_rollmean|ID) + (1|ITI) + (1|MotionDirection), data = ., REML=FALSE, na.action = na.omit))$coefficients[2,3])
LeftRT_N2c_per_sample$N2c_t_value<-as.double(LeftRT_N2c_per_sample$N2c_t_value)
ggplot(LeftRT_N2c_per_sample, aes(Time, N2c_t_value)) + geom_line(color= "#F8766D", size=1.4) +
geom_hline(yintercept=2, alpha = 0.5,  size=1.4) + geom_hline(yintercept=-2, alpha = 0.5,  size=1.4) + geom_vline(xintercept=0, alpha = 0.5,  size=1.4) +
coord_cartesian(ylim = c(-5, 4), xlim = c(-100, 600)) +
theme(axis.title.x = element_text(face="bold", size=14),
axis.text.x  = element_text(face="bold", angle=0,  size=14)) +
theme(axis.title.y = element_text(face="bold", size=14),
axis.text.y  = element_text(angle=0, vjust=0.5, size=14)) +
theme(plot.title = element_text(face="bold", size=16)) +
ggtitle("Forthcoming RT (Left Hemifield)\nPredicted by N2c Amplidude")
##Does N2i predict Right Hemifield target reaction time?
per_sample_RightHemifield <- data_Stim_locked_ERP2 %>% filter(., Hemifield=="Right", Time>-100, Time<1000) %>% group_by(Time)
RightRT_N2c_per_sample<-per_sample_RightHemifield %>%  do(N2i_t_value = summary(lmer(log(RT) ~ N2i_CSD_rollmean + (N2c_CSD_rollmean|ID) + (1|ITI) + (1|MotionDirection), data = ., REML=FALSE, na.action = na.omit))$coefficients[2,3])
RightRT_N2c_per_sample$N2i_t_value<-as.double(RightRT_N2c_per_sample$N2i_t_value)
ggplot(RightRT_N2c_per_sample, aes(Time, N2i_t_value)) + geom_line(color= "#00BFC4", size=1.4) +
geom_hline(yintercept=2, alpha = 0.5,  size=1.4) + geom_hline(yintercept=-2, alpha = 0.5,  size=1.4) + geom_vline(xintercept=0, alpha = 0.5,  size=1.4) +
coord_cartesian(ylim = c(-5, 4), xlim = c(-100, 600)) +
theme(axis.title.x = element_text(face="bold", size=14),
axis.text.x  = element_text(face="bold", angle=0,  size=14)) +
theme(axis.title.y = element_text(face="bold", size=14),
axis.text.y  = element_text(angle=0, vjust=0.5, size=14)) +
theme(plot.title = element_text(face="bold", size=16)) +
ggtitle("Forthcoming RT (Right Hemifield)\nPredicted by N2i Amplidude")
##Does N2c predict Left Hemifield target reaction time?
per_sample_LeftHemifield <- data_Stim_locked_ERP2 %>% filter(., Hemifield=="Left", Time>-100, Time<1000) %>% group_by(Time)
LeftRT_N2c_per_sample<-per_sample_LeftHemifield %>%  do(N2i_t_value = summary(lmer(log(RT) ~ N2i_CSD_rollmean + (N2c_CSD_rollmean|ID) + (1|ITI) + (1|MotionDirection), data = ., REML=FALSE, na.action = na.omit))$coefficients[2,3])
LeftRT_N2c_per_sample$N2i_t_value<-as.double(LeftRT_N2c_per_sample$N2i_t_value)
ggplot(LeftRT_N2c_per_sample, aes(Time, N2i_t_value)) + geom_line(color= "#F8766D", size=1.4) +
geom_hline(yintercept=2, alpha = 0.5,  size=1.4) + geom_hline(yintercept=-2, alpha = 0.5,  size=1.4) + geom_vline(xintercept=0, alpha = 0.5,  size=1.4) +
coord_cartesian(ylim = c(-5, 4), xlim = c(-100, 600)) +
theme(axis.title.x = element_text(face="bold", size=14),
axis.text.x  = element_text(face="bold", angle=0,  size=14)) +
theme(axis.title.y = element_text(face="bold", size=14),
axis.text.y  = element_text(angle=0, vjust=0.5, size=14)) +
theme(plot.title = element_text(face="bold", size=16)) +
ggtitle("Forthcoming RT (Left Hemifield)\nPredicted by N2i Amplidude")
data_Stim_locked_ERP2<-data_Stim_locked_ERP2 %>%
group_by(Trial) %>%
arrange(Trial, Time) %>%
mutate(CPP_CSD_rollmean = rollmean(x = CPP_CSD, 25, align = "center", fill = NA))
per_sample_RightHemifield <- data_Stim_locked_ERP2 %>% filter(., Hemifield=="Right", Time>-100, Time<1000) %>% group_by(Time)
RightRT_CPP_per_sample<-per_sample_RightHemifield %>%  do(N2c_t_value = summary(lmer(log(RT) ~ CPP_CSD_rollmean + (1|ID) + (1|ITI) + (1|MotionDirection), data = ., REML=FALSE, na.action = na.omit))$coefficients[2,3])
RightRT_CPP_per_sample$CPP_t_value<-as.double(RightRT_CPP_per_sample$N2c_t_value)
ggplot(RightRT_CPP_per_sample, aes(Time, CPP_t_value)) + geom_line() +
geom_hline(yintercept=2, alpha = 0.5) + geom_hline(yintercept=-2, alpha = 0.5) + geom_vline(xintercept=0, alpha = 0.5) +
ggtitle("t-values for RightHemifield RT \nPredicted by CPP over the epoch \n(uncorrected for multiple comparisons)")
per_sample_LeftHemifield <- data_Stim_locked_ERP2 %>% filter(., Hemifield=="Left", Time>-100, Time<1000) %>% group_by(Time)
LeftRT_CPP_per_sample<-per_sample_LeftHemifield %>%  do(N2c_t_value = summary(lmer(log(RT) ~ CPP_CSD_rollmean + (1|ID) + (1|ITI) + (1|MotionDirection), data = ., REML=FALSE, na.action = na.omit))$coefficients[2,3])
LeftRT_CPP_per_sample$CPP_t_value<-as.double(LeftRT_CPP_per_sample$N2c_t_value)
ggplot(LeftRT_CPP_per_sample, aes(Time, CPP_t_value)) + geom_line() +
geom_hline(yintercept=2, alpha = 0.5) + geom_hline(yintercept=-2, alpha = 0.5) + geom_vline(xintercept=0, alpha = 0.5) +
ggtitle("t-values for LeftHemifield RT \nPredicted by CPP over the epoch \n(uncorrected for multiple comparisons)")
per_sample_RightHemifield <- data_Stim_locked_ERP2 %>% filter(., Hemifield=="Right", Time>-100, Time<1000) %>% group_by(Time)
RightRT_CPP_per_sample<-per_sample_RightHemifield %>%  do(N2c_t_value = summary(lmer(log(RT) ~ CPP_CSD_rollmean + (CPP_CSD_rollmean|ID) + (1|ITI) + (1|MotionDirection), data = ., REML=FALSE, na.action = na.omit))$coefficients[2,3])
RightRT_CPP_per_sample$CPP_t_value<-as.double(RightRT_CPP_per_sample$N2c_t_value)
ggplot(RightRT_CPP_per_sample, aes(Time, CPP_t_value)) + geom_line() +
geom_hline(yintercept=2, alpha = 0.5) + geom_hline(yintercept=-2, alpha = 0.5) + geom_vline(xintercept=0, alpha = 0.5) +
ggtitle("t-values for RightHemifield RT \nPredicted by CPP over the epoch \n(uncorrected for multiple comparisons)")
per_sample_LeftHemifield <- data_Stim_locked_ERP2 %>% filter(., Hemifield=="Left", Time>-100, Time<1000) %>% group_by(Time)
LeftRT_CPP_per_sample<-per_sample_LeftHemifield %>%  do(N2c_t_value = summary(lmer(log(RT) ~ CPP_CSD_rollmean + (CPP_CSD_rollmean|ID) + (1|ITI) + (1|MotionDirection), data = ., REML=FALSE, na.action = na.omit))$coefficients[2,3])
LeftRT_CPP_per_sample$CPP_t_value<-as.double(LeftRT_CPP_per_sample$N2c_t_value)
ggplot(LeftRT_CPP_per_sample, aes(Time, CPP_t_value)) + geom_line() +
geom_hline(yintercept=2, alpha = 0.5) + geom_hline(yintercept=-2, alpha = 0.5) + geom_vline(xintercept=0, alpha = 0.5) +
ggtitle("t-values for LeftHemifield RT \nPredicted by CPP over the epoch \n(uncorrected for multiple comparisons)")
? rollapply
? lm
dolm <- function(x) coef(lm(USDZAR ~ ., data = as.data.frame(x))))
rollapplyr(fxr, 62, dolm, by.column = FALSE)
? rollapplyr
require(zoo)
rollapply(zoo(allRegData),
width=262,
FUN = function(Z)
{
t = lm(formula=y~x, data = as.data.frame(Z), na.rm=T);
return(t$coef)
},
by.column=FALSE, align="right")
data_Stim_locked_ERP2<-data_Stim_locked_ERP2 %>%
group_by(ID, Trial) %>%
arrange(Trial, Time) %>%
mutate(CPP_CSD_rollmean = rollmean(x = CPP_CSD, 25, align = "center", fill = NA))
per_sample_RightHemifield <- data_Stim_locked_ERP2 %>% filter(., Hemifield=="Right", Time>-100, Time<1000) %>% group_by(Time)
RightRT_CPP_per_sample<-per_sample_RightHemifield %>%  do(N2c_t_value = summary(lmer(log(RT) ~ CPP_CSD_rollmean + (CPP_CSD_rollmean|ID) + (1|ITI) + (1|MotionDirection), data = ., REML=FALSE, na.action = na.omit))$coefficients[2,3])
data_Stim_locked_ERP2<-data_Stim_locked_ERP2 %>%
group_by(ID, Trial) %>%
arrange(Trial, Time) %>%
mutate(N2c_CSD_rollmean = rollmean(x = N2c_CSD, 25, align = "center", fill = NA)) %>%
mutate(N2i_CSD_rollmean = rollmean(x = N2i_CSD, 25, align = "center", fill = NA))
##Does N2c predict Right Hemifield target reaction time?
per_sample_RightHemifield <- data_Stim_locked_ERP2 %>% filter(., Hemifield=="Right", Time>-100, Time<1000) %>% group_by(Time)
RightRT_N2c_per_sample<-per_sample_RightHemifield %>%  do(N2c_t_value = summary(lmer(log(RT) ~ N2c_CSD_rollmean + (N2c_CSD_rollmean|ID) + (1|ITI) + (1|MotionDirection), data = ., REML=FALSE, na.action = na.omit))$coefficients[2,3])
RightRT_N2c_per_sample$N2c_t_value<-as.double(RightRT_N2c_per_sample$N2c_t_value)
ggplot(RightRT_N2c_per_sample, aes(Time, N2c_t_value)) + geom_line(color= "#00BFC4",  size=1.4) +
geom_hline(yintercept=2, alpha = 0.5,  size=1.4) + geom_hline(yintercept=-2, alpha = 0.5,  size=1.4) + geom_vline(xintercept=0, alpha = 0.5,  size=1.4) +
coord_cartesian(ylim = c(-5, 4), xlim = c(-100, 600)) +
theme(axis.title.x = element_text(face="bold", size=14),
axis.text.x  = element_text(face="bold", angle=0,  size=14)) +
theme(axis.title.y = element_text(face="bold", size=14),
axis.text.y  = element_text(angle=0, vjust=0.5, size=14)) +
theme(plot.title = element_text(face="bold", size=16)) +
ggtitle("Forthcoming RT (Right Hemifield)\nPredicted by N2c Amplidude")
location<-"Monash"
# location<-"GersLaptop"
if (location=="Monash") {
setwd(("C:/GitHub/big_dots/Analyses Scripts_R"))
} else if (location=="GersLaptop") {
setwd(("C:/Users/loughnge/Documents/GitHub/big_dots/Analyses Scripts_R"))
} else setwd(("~"))
####################################
#######  How to use ################
####################################
# 1) Install the packages and software specified below. (consider also updating all installed packages by chosing Update on the Packages tab)
# 2) Set the working directory (setwd) above, and directory where you have "data_ParticipantLevel", "master_matrix_R" and "ID_vector" saved
# 3) Hit Knit Word (or Knit HTML)! (Output can take while due to bootstrapping the robust effect size and calculating the Bayesian Highest Density Iinterval)
####################################
######  FIRST TIME ONLY ############
####################################
#Remove # in front of the line below and run the code. Replace the # after installing the packages, otherwise the R markdown script will give errors.
# install.packages(c("MASS", "akima", "robustbase", "cobs", "robust", "mgcv", "scatterplot3d", "quantreg", "rrcov", "lars", "pwr", "trimcluster", "mc2d", "psych", "Rfit","MBESS", "BayesFactor", "PoweR", "ggplot2", "reshape2", "plyr", "devtools", "rmarkdown","gmodels", "HLMdiag", "car", "gridExtra", "bootES", "BEST","foreign","nlme","pastecs","multcomp","compute.es","ez","lattice","lme4","effects","diagram","png", "grid", "dplyr","readxl", "openxlsx", "haven","schoRsch", "lubridate", "nortest", "relaimpo", "leaps", "bootstrap"))
###################################################################################################################################
## load relevant libraries
library(foreign)
library(car)
library(nlme)
library(ggplot2)
library(pastecs)
library(psych)
library(multcomp)
library(compute.es)
library(ez)
library(lme4)
library(png)
library(grid)
library(readxl)
library(dplyr)
library(tidyr)
library(lubridate)
###### Import single trial data:
if (location=="Monash") {
data <- read.csv("C:/GitHub/big_dots/master_matrix_R_BigDots.csv", header=FALSE)
} else if (location=="GersLaptop") {
data <- read.csv("C:/Users/Dan/Documents/GitHub/big_dots/master_matrix_R_BigDots.csv", header=FALSE)
} else setwd(("~"))
#Import IDs:
if (location=="Monash") {
ID <- read.table("C:/GitHub/big_dots/ID_vector_BigDots.csv", quote="\"")
} else if (location=="GersLaptop") {
ID <- read.table("C:/Users/Dan/Documents/GitHub/big_dots/ID_vector_BigDots.csv", quote="\"")
} else setwd(("~"))
data$ID<-data[,1]
#Replace the participant numbers with IDs:
data[,1]<-ID[,1]
#Remove the seperate ID vector now it has been included into data dataframe
rm(ID)
drops <- c("ID")
data<-data[,!(names(data) %in% drops)]
###Read in Participant Demographics (note for Sex 1=male)
Demographics<-read_excel("Participant_Demographics.xlsx") %>% #then calculate Age at testing date:
mutate(Age_as_period=as.period(interval(Date_Of_Birth, Date_Of_Testing), units="years")) %>%
mutate(Sex = ifelse(Sex==1, "Male", "Female"))
#Calculate Age in numeric format
Demographics$Age<-as.numeric(difftime(as.Date(Demographics$Date_Of_Testing), as.Date(Demographics$Date_Of_Birth), units = "days")/365)
summary(Demographics$Age)
#########################################################################################################################
data<- data %>% #Rename data columns:
rename(.,
ID=V1,
TotalTrialNumber=V2,
Trial=V3,
ITI=V4,
Hemifield=V5,
Accuracy=V6,
Art_neg500_0=V7,
Art_neg100_100PR=V8,
Art_neg500_100PR=V9,
Art_neg100_1000=V10,
FixBreak_neg500_0=V11,
FixBreak_neg100_100PR=V12,
FixBreak_neg500_100PR=V13,
FixBreak_neg100_1000=V14,
RT=V15,
PreAlphaPower=V16,
PreAlphaPowerLH=V17,
PreAlphaPowerRH=V18,
PreAlphaAsym=V19,
PostAlphaPowerLH=V20,
PostAlphaPowerRH=V21,
Location=V22) %>% #next make the required columns into factors:
mutate_each_(funs(factor), c("ITI", "Hemifield", "Accuracy")) %>% #next re-class required vectors into Logicals:
mutate_at(vars(starts_with("Art_")), funs(as.logical)) %>%
mutate_at(vars(starts_with("FixBreak_")), funs(as.logical)) %>% #next use the ! negation operator to reverse of a TRUE/FALSE vectors:
mutate_if(purrr::is_logical, funs(!.)) %>% #next Rename factor Levels:
mutate(Hemifield = ifelse(Hemifield==1, "Left", "Right"),
Accuracy= ifelse(Accuracy==1, "Hit", ifelse(Accuracy==2, "WrongButton", "Miss")),
Location = ifelse(Location==1, "TCD", "Monash"))
Demographics <-Demographics[Demographics$ID %in% data$ID, ]
###############Data Cleaning For Single Trial Data######################
#Check number of Trials for each participant by running the function 'length',
#on "data$RT" for each DAT1_3UTR, broken down by ID + Light
num_trials1 <- data %>% group_by(ID) %>% summarise( Trials = length(RT))
summary(num_trials1$Trials)
##################Accuracy ##########################
Accuracy_checker <- data %>% group_by(ID) %>%
summarise(Hits  = sum(Accuracy=="Hit"),
Misses = sum(Accuracy=="Miss" | Accuracy=="WrongButton")) %>%
mutate(Total=Hits+Misses,
Accuracy_overall= (Hits/Total)*100)
summary(Accuracy_checker$Accuracy_overall)
##Add in overall accuracy
data <- merge(data, Accuracy_checker, by.x = "ID", by.y = "ID")
######Test for effect of Hemifield on Accuracy:
# Accuracy_checker <- data %>% group_by(ID, Hemifield) %>%
#                     summarise(Hits  = sum(Accuracy=="Hit"),
#                                Misses = sum(Accuracy=="Miss" | Accuracy=="WrongButton")) %>%
#                     mutate(Total=Hits+Misses,
#                            Accuracy_overall= (Hits/Total)*100)
# log <- capture.output({
#    Hemifield_Perm <- ezPerm(data = data.frame(Accuracy_checker)
#                           , dv = .(Accuracy_overall)
#                           , wid = .(ID)
#                           , within = .(Hemifield)
#                           , perms = 1000);
#  })
# print("Factorial Permutation test for the effect of Hemifield Accuracy:")
# print(Hemifield_Perm);
##########################################################################
###Remove trials where:
#RT longer than 1000ms (i.e. after target finished)
#RT faster than 100ms (i.e. too fast must be false alarm) or RT=0 (i.e. they did not respond)
#Kick out trials with fixation breaks:
data<-filter(data, RT<1500 & RT>150 & !FixBreak_neg100_100PR)
############################################ Log transform:
##############################################################################################
data$log_RT<-log(data$RT) #log
#####Z-score each participant's log_RT data ####
data$IDbyITIbyHemifield<-interaction(data$ID, data$ITI, data$Hemifield)
#calculate mean and sd
m <- tapply(data$log_RT,data$IDbyITIbyHemifield,mean, na.rm = T)
s <- tapply(data$log_RT,data$IDbyITIbyHemifield,sd, na.rm = T)
#calculate log_RT.Z and save it inside data.frame
data$log_RT.Z <- (data$log_RT-m[data$IDbyITIbyHemifield])/s[data$IDbyITIbyHemifield]
#Remove trials where absolute log_RT.Z>3 (i.e. remove outlier RTs)
data<-data[!abs(data$log_RT.Z)>3,]
#plot again after outlier removal:
ggplot(data, aes(RT))  + geom_histogram(aes(y=..count..), colour="black", fill="white")
ggplot(data, aes(log_RT))  + geom_histogram(aes(y=..count..), colour="black", fill="white")
#Calculate the number of trials each participant has left after fixation break trials are kicked out:
num_trials2 <- data %>% group_by(ID) %>% summarise( Trials = length(RT))
summary(num_trials2$Trials)
#Calculate alpha desynchronisation by subtracting Pre-target Alpha from post target alpha
data$AlphaDesyncRH<-(data$PreAlphaPowerRH)-(data$PostAlphaPowerRH)
data$AlphaDesyncLH<-data$PreAlphaPowerLH-data$PostAlphaPowerLH
# Make PostAlpha contralateral (PostAlpha_c) and -Ipsilateral (PostAlpha_i) variables:
A<-data$Hemifield=="Left"
#Absolute post target alpha
data$PostAlpha_c[A]<-data$PostAlphaPowerRH[A]
data$PostAlpha_c[!A]<-data$PostAlphaPowerLH[!A]
data$PostAlpha_i[!A]<-data$PostAlphaPowerRH[!A]
data$PostAlpha_i[A]<-data$PostAlphaPowerLH[A]
#Post target Alpha desynchronisation
data$AlphaDesync_c[A]<-data$AlphaDesyncRH[A]
data$AlphaDesync_c[!A]<-data$AlphaDesyncLH[!A]
data$AlphaDesync_i[!A]<-data$AlphaDesyncRH[!A]
data$AlphaDesync_i[A]<-data$AlphaDesyncLH[A]
rm(A)
####Import participant_level_matrix with ERP measures
if (location=="Monash") {
participant_level <- read.csv("C:/GitHub/big_dots/participant_level_matrix.csv", header=FALSE)
} else if (location=="DansLaptop") {
participant_level <- read.csv("C:/Users/Dan/Documents/GitHub/big_dots/participant_level_matrix.csv", header=FALSE)
} else setwd(("~"))
#Import IDs:
if (location=="Monash") {
ID <- read.table("C:/GitHub/big_dots/IDs.csv", quote="\"")
} else if (location=="DansLaptop") {
ID <- read.csv("C:/Users/Dan/Documents/GitHub/big_dots/IDs.csv", header=F)
} else setwd(("~"))
ID<-plyr::rename(ID,c("V1"="ID"))
participant_level$ID<-ID$ID
rm(ID)
participant_level<- participant_level %>% #Rename data columns:
rename(.,
N2c_LeftTarget=V1,
N2c_RightTarget=V2,
N2i_LeftTarget=V3,
N2i_RightTarget=V4,
N2c_latency_LeftTarget=V5,
N2c_latency_RightTarget=V6,
N2i_latency_LeftTarget=V7,
N2i_latency_RightTarget=V8,
CPPonset_LeftTarget=V9,
CPPonset_RightTarget=V10,
CPPslope_LeftTarget=V11,
CPPslope_RightTarget=V12,
Location=V13 ) %>% ##next calculate the ERP asymmetry measures:
mutate(.,
N2c_Asym = (N2c_LeftTarget-N2c_RightTarget)/(N2c_LeftTarget+N2c_RightTarget),
N2i_Asym = (N2i_LeftTarget-N2i_RightTarget)/(N2i_LeftTarget+N2i_RightTarget),
N2c_latency_Asym = (N2c_latency_LeftTarget-N2c_latency_RightTarget)/(N2c_latency_LeftTarget+N2c_latency_RightTarget),
N2i_latency_Asym =(N2i_latency_LeftTarget-N2i_latency_RightTarget)/(N2i_latency_LeftTarget+N2i_latency_RightTarget),
CPPonset_Asym = (CPPonset_LeftTarget-CPPonset_RightTarget)/(CPPonset_LeftTarget+CPPonset_RightTarget),
CPPslope_Asym = (CPPslope_LeftTarget-CPPslope_RightTarget)/(CPPslope_LeftTarget+CPPslope_RightTarget),
Location = ifelse(Location==1, "TCD", "Monash")
)
####################################################################################
#Collapse each participant's PreAlpha trials to participant level
PreAlphaAsym_collapsed<- data %>%
filter(!Art_neg500_0, !FixBreak_neg500_0) %>%
group_by(ID) %>%
summarise(PreAlphaAsym=mean(PreAlphaAsym))
#Merge it in with the ERP measures
participant_level<-merge(participant_level, PreAlphaAsym_collapsed, by.x = "ID", by.y = "ID")
#Collapse each participant's PostAlpha trials to participant level
PostAlphaAsym_collapsed<- data %>%
filter(!Art_neg500_0, !FixBreak_neg500_0, PostAlpha_c!=0, PostAlpha_i!=0) %>%
mutate(PostAlphaAsym=(PostAlpha_c-PostAlpha_i)/(PostAlpha_c+PostAlpha_i)) %>% #contra - ipsi asym
group_by(ID) %>%
summarise(PostAlphaAsym=mean(PostAlphaAsym))
#Merge it in with the ERP measures
participant_level<-merge(participant_level, PostAlphaAsym_collapsed, by.x = "ID", by.y = "ID")
#Collapse each participant's Post-target AlphaDesync single trials to participant level
AlphaDesync_c_collapsed<- data %>%
filter(!Art_neg500_100PR, !FixBreak_neg500_100PR, AlphaDesync_c!=0) %>%
group_by(ID, Hemifield) %>%
summarise(AlphaDesync_c=mean(AlphaDesync_c)) %>% #next bring Target-Hemifield up into wide format:
spread(Hemifield, AlphaDesync_c) %>% #next rename
rename(AlphaDesync_c_LeftTarget=Left, AlphaDesync_c_RightTarget=Right) %>% # next Calculate RT asymmetry:
mutate(AlphaDesync_c_Asym=(AlphaDesync_c_LeftTarget-AlphaDesync_c_RightTarget)/(AlphaDesync_c_LeftTarget+AlphaDesync_c_RightTarget))
#Merge it in with the ERP measures
participant_level<-merge(participant_level, AlphaDesync_c_collapsed, by.x = "ID", by.y = "ID")
AlphaDesync_i_collapsed<- data %>%
filter(!Art_neg500_100PR, !FixBreak_neg500_100PR, AlphaDesync_i!=0) %>%
group_by(ID, Hemifield) %>%
summarise(AlphaDesync_i=mean(AlphaDesync_i)) %>% #next bring Target-Hemifield up into wide format:
spread(Hemifield, AlphaDesync_i) %>% #next rename
rename(AlphaDesync_i_LeftTarget=Left, AlphaDesync_i_RightTarget=Right) %>% # next Calculate RT asymmetry:
mutate(AlphaDesync_i_Asym=(AlphaDesync_i_LeftTarget-AlphaDesync_i_RightTarget)/(AlphaDesync_i_LeftTarget+AlphaDesync_i_RightTarget))
#Merge it in with the ERP measures
participant_level<-merge(participant_level, AlphaDesync_i_collapsed, by.x = "ID", by.y = "ID")
#Collapse each participant's RT single trials to participant level
RT_collapsed<- data %>%
group_by(ID, Hemifield) %>%
summarise(RT=mean(RT)) %>% #next bring Target-Hemifield up into wide format:
spread(Hemifield, RT) %>% #next rename
rename(RT_Left=Left, RT_Right=Right) %>% # next Calculate RT asymmetry:
mutate(RT_Asym=(RT_Left-RT_Right)/(RT_Left+RT_Right))
#Merge it in with the ERP measures
participant_level<-merge(participant_level, RT_collapsed, by.x = "ID", by.y = "ID")
#Transform it to long format
participant_level_long<-participant_level %>%
gather(measure_type, data, -ID, -Location) %>%
na.omit()
####Find outliers in the Participant level data (abs z-score >3)####
#################################################################
#Calculate Z scores inside measure_type type TO REMOVE OUTLIERS
#Z-score each participant's data inside measure_type ####
#calculate mean and sd
m <- tapply(participant_level_long$data,participant_level_long$measure_type,mean, na.rm = T)
s <- tapply(participant_level_long$data,participant_level_long$measure_type,sd, na.rm = T)
#calculate data.Z and save it inside participant_level_long
participant_level_long$data.Z <- (participant_level_long$data-m[participant_level_long$measure_type])/s[participant_level_long$measure_type]
#Remove trials where absolute data.Z>3 (i.e. remove outlier RTs)
# participant_level_long<-participant_level_long[!abs(participant_level_long$data.Z)>3,]
# Shift extream outliers back to +/- 3 standard deviations from the mean
participant_level_long$data[participant_level_long$data.Z>3]<-m[participant_level_long$measure_type][participant_level_long$data.Z>3] + 3*s[participant_level_long$measure_type][participant_level_long$data.Z>3]
participant_level_long$data[participant_level_long$data.Z<(-3)]<-m[participant_level_long$measure_type][participant_level_long$data.Z<(-3)] - 3*s[participant_level_long$measure_type][participant_level_long$data.Z<(-3)]
#calculate data.Z again and save it inside participant_level_long
participant_level_long$data.Z <- (participant_level_long$data-m[participant_level_long$measure_type])/s[participant_level_long$measure_type]
#Plot density plots again after outlier removal
ggplot(participant_level_long, aes(data))  + geom_density() + facet_wrap(~ measure_type, scales="free")
#change measure_type to factor class
participant_level_long$measure_type<-as.factor(participant_level_long$measure_type)
#Put it back into long format so I can use lapply to do t-test on columns
participant_level<-participant_level_long %>% select(., -data.Z)  %>%
spread(measure_type, data)
#Merge in the Demographics
participant_level<-merge(participant_level, Demographics, by.x = "ID", by.y = "ID")
####################################################################################
fit <- lm(RT_Asym~ PreAlphaAsym + N2c_Asym + CPPslope_Asym + CPPonset_Asym, data=participant_level)
coef(fit)
coef(lm(RT_Asym~ PreAlphaAsym, data=participant_level))
z <- zoo(11:15, as.Date(31:35))
zoo
z
rollapply(z, 2, mean)
z <- zoo(11:15, as.Date(31:35))
rollapply(z, 2, mean)
seat <- as.zoo(log(UKDriverDeaths))
seat
glimpse(seat)
View(## rolling regression:
## set up multivariate zoo series with
## number of UK driver deaths and lags 1 and 12
seat <- as.zoo(log(UKDriverDeaths))
time(seat) <- as.yearmon(time(seat))
seat <- merge(y = seat, y1 = lag(seat, k = -1),
y12 = lag(seat, k = -12), all = FALSE)
## run a rolling regression with a 3-year time window
## (similar to a SARIMA(1,0,0)(1,0,0)_12 fitted by OLS)
rr <- rollapply(seat, width = 36,
FUN = function(z) coef(lm(y ~ y1 + y12, data = as.data.frame(z))),
by.column = FALSE, align = "right")
## plot the changes in coefficients
## showing the shifts after the oil crisis in Oct 1973
## and after the seatbelt legislation change in Jan 1983
plot(rr))
View(z)
seat <- as.zoo(log(UKDriverDeaths))
View(z)
time(seat) <- as.yearmon(time(seat))
seat <- merge(y = seat, y1 = lag(seat, k = -1),
y12 = lag(seat, k = -12), all = FALSE)
View(seat)
rr <- rollapply(seat, width = 36,
FUN = function(z) coef(lm(y ~ y1 + y12, data = as.data.frame(z))),
by.column = FALSE, align = "right")
plot(rr)
dan<-data_Stim_locked_ERP2 %>%
group_by(ID, Trial) %>%
arrange(Trial, Time) %>%
do(rollapply(., width = 25,
FUN = function(z) coef(lm(CPP_CSD ~ Time, data = as.data.frame(z))),
by.column = FALSE, align = "right"))
View(Dan)
View(dan)
18*12
17.95*12
(17.95*12)-150
data_gaze<- data_Stim_locked_ERP %>% filter(GAZE_X<768, GAZE_Y<1024, GAZE_X>0, GAZE_Y>0, Time>-100, Time<1000) #
## geom_point NO FixationBreak, valud RT
ggplot(filter(data_gaze, !FixationBreak, RT<1500, RT>200), aes(GAZE_X, GAZE_Y)) +
geom_point(alpha = 0.1) +
coord_cartesian(xlim = c(0, 1024),  ylim = c(0, 768)) +
geom_vline(xintercept=512) + geom_hline(yintercept=384) +
ggtitle("Gaze Valid Trials")
ggplot(filter(data_gaze, !FixationBreak, RT<1500, RT>200), aes(GAZE_X, GAZE_Y, color = Time)) +
geom_point(alpha = 0.1) +
coord_cartesian(xlim = c(0, 1024),  ylim = c(0, 768)) +
geom_vline(xintercept=512) + geom_hline(yintercept=384) +
ggtitle("Gaze during coherent motion, by Hemifield and Time (Stimulus locked)") + facet_wrap(~ ID)
library(gapminder)
library(ggplot2)
library(gganimate)
data_gaze_Resp_Locked<- data_Resp_locked_ERP %>% filter(GAZE_X<768, GAZE_Y<1024, GAZE_X>0, GAZE_Y>0)
ggplot(filter(data_gaze_Resp_Locked, !FixationBreak), aes(GAZE_X, GAZE_Y, color = Time)) +
geom_point(alpha = 0.1) +
coord_cartesian(xlim = c(0, 1024),  ylim = c(0, 768)) +
geom_vline(xintercept=512) + geom_hline(yintercept=384) +
ggtitle("Gaze during coherent motion, by Hemifield and Time (Stimulus locked)") + facet_wrap(~ Hemifield)
p<-ggplot(filter(data_gaze_Resp_Locked, !FixationBreak), aes(GAZE_X, GAZE_Y, color = Hemifield, frame = Time)) +
geom_point(size=5) +
coord_cartesian(xlim = c(0, 1024),  ylim = c(0, 768)) +
geom_vline(xintercept=512) + geom_hline(yintercept=384) + facet_wrap(~ ID)
gg_animate(p, interval = .2)
> rollapply
? rollapply
(4000000000-168200000)/168200000
(4000000000-168200000)/168200000)
(4000000000-168200000)/168200000)
(4000000000-168200000)/168200000
((4000000000-168200000)/168200000)*100
((1000000000-168200000)/168200000)*100
