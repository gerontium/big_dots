---
title: "BigDots"
author: "Daniel Newman"
date: "12 June 2016"
output:
  html_document:
    fig_width: 8
    keep_md: yes
  word_document: default
---

```{r Load and Pre-Process the single trial Data, echo=FALSE, include=FALSE}

####Which computer/directory is this being run on?
location<-"Monash"
# location<-"GersLaptop"

if (location=="Monash") {
    setwd(("C:/GitHub/big_dots/Analyses Scripts_R"))
} else if (location=="GersLaptop") {
    setwd(("C:/Users/loughnge/Documents/GitHub/big_dots/Analyses Scripts_R"))
} else setwd(("~"))





####################################
#######  How to use ################
####################################

# 1) Install the packages and software specified below. (consider also updating all installed packages by chosing Update on the Packages tab)
# 2) Set the working directory (setwd) above, and directory where you have "data_ParticipantLevel", "master_matrix_R" and "ID_vector" saved
# 3) Hit Knit Word (or Knit HTML)! (Output can take while due to bootstrapping the robust effect size and calculating the Bayesian Highest Density Iinterval)


####################################
######  FIRST TIME ONLY ############
####################################

#Remove # in front of the line below and run the code. Replace the # after installing the packages, otherwise the R markdown script will give errors.

# install.packages(c("MASS", "akima", "robustbase", "cobs", "robust", "mgcv", "scatterplot3d", "quantreg", "rrcov", "lars", "pwr", "trimcluster", "mc2d", "psych", "Rfit","MBESS", "BayesFactor", "PoweR", "ggplot2", "reshape2", "plyr", "devtools", "rmarkdown","gmodels", "HLMdiag", "car", "gridExtra", "bootES", "BEST","foreign","nlme","pastecs","multcomp","ggplot2","compute.es","ez","lattice","lme4","effects","diagram","png", "grid", "dplyr","readxl", "openxlsx", "haven","schoRsch"))

###################################################################################################################################
detach("package:dplyr", unload=TRUE)
## Install relevant libraries 
library(foreign)
library(car)
library(nlme)
library(ggplot2)
library(pastecs)
library(psych)
library(plyr)
library(multcomp)
library(reshape2)
library(compute.es)
library(ez)
library(lattice)
library(lme4)
library(png)
library(grid)
library(readxl)

###### Import single trial data:
if (location=="Monash") {
data <- read.csv("C:/GitHub/big_dots/master_matrix_R_BigDots.csv", header=FALSE)
} else if (location=="GersLaptop") {
data <- read.csv("C:/Users/Dan/Documents/GitHub/big_dots/master_matrix_R_BigDots.csv", header=FALSE)
} else setwd(("~"))
#Import IDs:
if (location=="Monash") {
ID <- read.table("C:/GitHub/big_dots/ID_vector_BigDots.csv", quote="\"")
} else if (location=="GersLaptop") {
ID <- read.table("C:/Users/Dan/Documents/GitHub/big_dots/ID_vector_BigDots.csv", quote="\"")
} else setwd(("~"))

data$ID<-data[,1]
#Replace the participant numbers with IDs:
data[,1]<-ID[,1]
#Remove the seperate ID vector now it has been included into data dataframe
rm(ID)
drops <- c("ID")
data<-data[,!(names(data) %in% drops)]


###Read in SLF data from the SPSS file Tim Sent
SLF<-haven::read_sav("S:/R-MNHS-SPP/Bellgrove-data/4. Dan Newman/Participant Folders_new/SLF_metrics_290616.sav")
DARIS_ID<-readxl::read_excel("S:/R-MNHS-SPP/Bellgrove-data/4. Dan Newman/Participant Folders_new/DARIS_ID.xlsx")
SLF2<-merge(SLF, DARIS_ID, by.x = "DARIS", by.y = "DARIS")
ID_Order <- read_excel("ID_Order_for_Matlab.xlsx")

SLF2<-merge(SLF2, ID_Order, by.x = "ID", by.y = "ID", all=T) 

SLF2<-dplyr::arrange(SLF2, Order)

# xlsx::write.xlsx(SLF2, "SLF.xlsx", row.names=F)

#########################################################################################################################


#Rename data columns:
data<-rename(data, c("V1"="ID","V2"="TotalTrialNumber","V3"="Trial","V4"="ITI","V5"="Hemifield", "V6"="Accuracy",
                     "V7"="Art_neg500_0", "V8"="Art_neg100_100PR","V9"="Art_neg500_100PR", "V10"="Art_neg100_1000",
                     "V11"="FixBreak_neg500_0", "V12"="FixBreak_neg100_100PR","V13"="FixBreak_neg500_100PR", "V14"="FixBreak_neg100_1000",
                     "V15"="RT"))   

# data<-dplyr::rename(data, "V1"="ID","V2"="TotalTrialNumber","V3"="Trial","V4"="ITI","V5"="Hemifield", "V6"="Accuracy",
#                      "V7"="Art_neg500_0", "V8"="Art_neg100_100PR","V9"="Art_neg500_100PR", "V10"="Art_neg100_1000",
#                      "V11"="FixBreak_neg500_0", "V12"="FixBreak_neg100_100PR","V13"="FixBreak_neg500_100PR", "V14"="FixBreak_neg100_1000",
#                      "V15"="RT")   

#NOTE: FOR N2c/i,  the _GA or _PA suffix indicates whether N2c/i is measured with a measurement window based
#on Grand average (GA) peak N2c/i latency,  or based on Participant level average (PA) peak N2c/i latency
             
#Make the required columns into factors:
data$ITI <- factor(data$ITI)
data$Hemifield <- factor(data$Hemifield)
data$Accuracy <- factor(data$Accuracy)

#Rename factor Levels:
data$Hemifield <- revalue(data$Hemifield, c("1"="Left", "2"="Right"))
data$Accuracy <- revalue(data$Accuracy, c("1"="Hit", "0"="RejectedTrial", "2"="WrongButton", "3"="Miss"))


#Re-class required vectors into Logicals:
data$Art_neg500_0<-!as.logical(data$Art_neg500_0)
data$Art_neg100_100PR<-!as.logical(data$Art_neg100_100PR)
data$Art_neg500_100PR<-!as.logical(data$Art_neg500_100PR)
data$Art_neg100_1000<-!as.logical(data$Art_neg100_1000)
data$FixBreak_neg500_0<-!as.logical(data$FixBreak_neg500_0)
data$FixBreak_neg100_100PR<-!as.logical(data$FixBreak_neg100_100PR)
data$FixBreak_neg500_100PR<-!as.logical(data$FixBreak_neg500_100PR)
data$FixBreak_neg100_1000<-!as.logical(data$FixBreak_neg100_1000)



############################################ Import DAT1 Data ##############################################
DAT1 <- read_excel("DAT1genotypes_forR.xlsx") 
#Make the required columns into factors:
DAT1$DAT1_3UTR_VNTRraw <- factor(DAT1$DAT1_3UTR_VNTRraw)
DAT1$DAT1_Int8_VNTRraw <- factor(DAT1$DAT1_Int8_VNTRraw)
DAT1$Site <- factor(DAT1$Site)
DAT1$ID<-as.factor(DAT1$ID)

DAT1$DAT1_10_10_repeats  <- revalue(DAT1$DAT1_3UTR_VNTRraw , 
                                       c("10 10"="Two", 
                                         "10 11"="One", 
                                         "7 10"="One",
                                         "7 9"="Zero",
                                         "8 11"="Zero",
                                         "9 10"="One",
                                         "9 9"="Zero"))
summary(DAT1$DAT1_10_10_repeats)

DAT1$DAT1_3UTR  <- revalue(DAT1$DAT1_3UTR_VNTRraw , 
                                 c("10 10"="10_10_repeat", 
                                   "10 11"="non10_10_repeat", 
                                   "7 10"="non10_10_repeat",
                                   "7 9"="non10_10_repeat",
                                   "8 11"="non10_10_repeat",
                                   "9 10"="non10_10_repeat",
                                  "9 9"="non10_10_repeat"))
summary(DAT1$DAT1_3UTR)

DAT1$DAT1_int8  <- revalue(DAT1$DAT1_Int8_VNTRraw , 
                                 c("6 6"="6_6_repeat", 
                                   "5 6"="non6_6_repeat", 
                                   "5 5"="non6_6_repeat"))
summary(DAT1$DAT1_int8)

#Only keep Genotypes for the participants who we actually tested on big dots 
#(there are a few extra participant genotypes in the DAT1 sheet)
DAT1 <-DAT1[DAT1$ID %in% data$ID, ]

#How many participant's have missing DAT1 genotype?
summary(DAT1$DAT1_3UTR) #So 4 participant have missing DAT1 genotype

#### Merge the data sets together
data<-merge(data, DAT1, by.x = "ID", by.y = "ID") 



### Merge in the SLF data
SLF2 <-SLF2[SLF2$ID %in% data$ID, ] 
data<-merge(data, SLF2, by.x = "ID", by.y = "ID") 

################################################################################################
#########Creat ordered DAT1 genotype .xlsx file for matlab:

 # ID_Order <- read_excel("ID_Order_for_Matlab.xlsx")
 # DAT1<-merge(DAT1, ID_Order, by.x = "ID", by.y = "ID")
 # 
 # DAT1$DAT1_10_10  <- revalue(DAT1$DAT1_10_10_repeats ,
 #                                        c("Zero"="0",
 #                                          "One"="1",
 #                                          "Two"="2"))
 # DAT1<-dplyr::arrange(DAT1, Order)
 # DAT1genotypes_for_Matlab<-dplyr::select(DAT1, ID, DAT1_10_10)
 # xlsx::write.xlsx(DAT1genotypes_for_Matlab, file = "C:/GitHub/big_dots/DAT1genotypes_for_Matlab.xlsx", row.names = F)
 

###############Data Cleaning For Single Trial Data######################


#Check number of Trials for each participant by running the function 'length', 
#on "data$RT" for each DAT1_3UTR, broken down by ID + Light
num_trials1 <- ddply(data, c("ID"), summarise,
               Trials    = length(RT))
summary(num_trials1$Trials)
mean(num_trials1$Trials)

##################Accuracy ##########################
Accuracy_checker <- ddply(data, c("ID"), summarise,
               Hits  = sum(Accuracy=="Hit"),
               Misses = sum(Accuracy=="Miss" | Accuracy=="WrongButton"))
Accuracy_checker$Total=Accuracy_checker$Hits+Accuracy_checker$Misses
Accuracy_checker$Accuracy_overall=(Accuracy_checker$Hits/Accuracy_checker$Total)*100
summary(Accuracy_checker$Accuracy_overall)

##Add in overall accuracy 
data <- merge(data, Accuracy_checker, by.x = "ID", by.y = "ID")

#Remove trials where RT=0 (i.e. they did not respond)
data<-data[data$RT!=0,]
#Remove trials where RT longer than 1000ms (i.e. after target finished)
data<-data[data$RT<1500,]
#Remove trials where RT faster than 100ms (i.e. too fast must be false alarm)
data<-data[data$RT>150,]
#Kick out trials with fixation breaks:
data<-data[!data$FixBreak_neg100_100PR,]

############################################ Log transform:
##############################################################################################
data$log_RT<-log(data$RT) #log
#####Z-score each participant's log_RT data ####
data$IDbyITIbyHemifield<-interaction(data$ID, data$ITI, data$Hemifield)
#calculate mean and sd 
m <- tapply(data$log_RT,data$IDbyITIbyHemifield,mean)
s <- sqrt(tapply(data$log_RT,data$IDbyITIbyHemifield,var))
#calculate log_RT.Z and save it inside data.frame
data$log_RT.Z <- (data$log_RT-m[data$IDbyITIbyHemifield])/s[data$IDbyITIbyHemifield]
#check that Z scores have mean=0 and std=1 
log_RT.Z_checker <- ddply(data, c("ID", "ITI", "Hemifield"), summarise,
               N    = length(log_RT.Z ),
               mean = round(mean(log_RT.Z )),
               sd   = sd(log_RT.Z ),
               se   = sd / sqrt(N))
summary(log_RT.Z_checker$mean)#make sure mean is 0
summary(log_RT.Z_checker$sd) #Make sure SD is 1

#Remove trials where absolute log_RT.Z>3 (i.e. remove outlier RTs)
data<-data[!abs(data$log_RT.Z)>3,]


#plot again after outlier removal:
ggplot(data, aes(RT))  + geom_histogram(aes(y=..count..), colour="black", fill="white") 
ggplot(data, aes(log_RT))  + geom_histogram(aes(y=..count..), colour="black", fill="white") 


#Calculate the number of trials each participant has left after fixation break trials are kicked out:
num_trials2 <- ddply(data, c("ID"), summarise,
               Num_RT_Trials    = length(RT))


####Import participant_level_matrix with ERP measures
if (location=="Monash") {
data_participant_level <- read.csv("C:/GitHub/big_dots/participant_level_matrix.csv", header=FALSE)
} else if (location=="DansLaptop") {
data_participant_level <- read.csv("C:/Users/Dan/Documents/GitHub/big_dots/participant_level_matrix.csv", header=FALSE)
} else setwd(("~"))
#Import IDs:
if (location=="Monash") {
ID <- read.table("C:/GitHub/big_dots/IDs.csv", quote="\"")
} else if (location=="DansLaptop") {
ID <- read.csv("C:/Users/Dan/Documents/GitHub/big_dots/IDs.csv", header=F)
} else setwd(("~"))
ID<-plyr::rename(ID,c("V1"="ID"))
data_participant_level$ID<-ID$ID
rm(ID)

data_participant_level<-rename(data_participant_level, c("V1"="N2c_LeftTarget", "V2"="N2c_RightTarget","V3"="N2i_LeftTarget","V4"="N2i_RightTarget","V5"="N2c_latency_LeftTarget",
"V6"="N2c_latency_RightTarget","V7"="N2i_latency_LeftTarget","V8"="N2i_latency_RightTarget",
"V9"="CPPonset_LeftTarget","V10"="CPPonset_RightTarget","V11"="CPPslope_LeftTarget","V12"="CPPslope_RightTarget"))

###Calculate Asymmetry meeasres
library(dplyr)
data_participant_level<-data_participant_level %>% mutate(., 
                                  N2c_Asym = (N2c_LeftTarget-N2c_RightTarget)/(N2c_LeftTarget+N2c_RightTarget), 
                                  N2i_Asym = (N2i_LeftTarget-N2i_RightTarget)/(N2i_LeftTarget+N2i_RightTarget),
                                  N2c_latency_Asym = (N2c_latency_LeftTarget-N2c_latency_RightTarget)/(N2c_latency_LeftTarget+N2c_latency_RightTarget), 
                                  N2i_latency_Asym =(N2i_latency_LeftTarget-N2i_latency_RightTarget)/(N2i_latency_LeftTarget+N2i_latency_RightTarget),
                                  CPPonset_Asym = (CPPonset_LeftTarget-CPPonset_RightTarget)/(CPPonset_LeftTarget+CPPonset_RightTarget),
                                  CPPslope_Asym = (CPPslope_LeftTarget-CPPslope_RightTarget)/(CPPslope_LeftTarget+CPPslope_RightTarget)
                                  )

detach("package:dplyr", unload=TRUE)
library(plyr)

```



#t-tests for the relationship between DAT1 3UTR genotype and all of the Asymmetry measures (i.e. RT, N2, CPP and SLF asymmetry) 
```{r, echo=FALSE, warning=FALSE}
######Calculate RT asymmetry Index and add it to "data_participant_level"######
#Collapse each participant's trials accross ITI
RT_collapsed<-ddply(data, .(ID, Hemifield, DAT1_3UTR), summarise, RT=mean(RT))
#Bring Target-Hemifield up into wide format
RT_collapsed <- dcast(RT_collapsed, ID  ~ Hemifield, value.var="RT", fun.aggregate=mean)
RT_collapsed<-rename(RT_collapsed, c("Left"="RT_Left", "Right"="RT_Right"))
#Calculate RT asymmetry
RT_collapsed$RT_Asym<-(RT_collapsed$RT_Left-RT_collapsed$RT_Right)/(RT_collapsed$RT_Left+RT_collapsed$RT_Right)

#Add in the DAT1 measures
RT_collapsed<-merge(RT_collapsed, DAT1, by.x = "ID", by.y = "ID") 

#Add in the ERP measures
RT_collapsed<-merge(RT_collapsed, data_participant_level, by.x = "ID", by.y = "ID") 

#Add in the SLF data
RT_collapsed<-merge(RT_collapsed, SLF2, by.x = "ID", by.y = "ID") 

#Remove DAT1 Int8 measures, only interested in 3'UTR
RT_collapsed<-dplyr::select(RT_collapsed, -contains("int"))

#Remove outliers
# RT_collapsed$RT_Asym.Z<-scale(RT_collapsed$RT_Asym)
# RT_collapsed<-RT_collapsed[abs(RT_collapsed$RT_Asym.Z)<3,]
# 
# t.test(RT_collapsed$RT_Asym ~ RT_collapsed$DAT1_3UTR, na.action=na.omit)


library(dplyr)
library(tidyr)
#Get the required data i.e. ID, DAT1_3UTR and all the asymmeyry index measures
Asym_data<-RT_collapsed %>% select(., ID, DAT1_3UTR, contains("_LI_"), contains("Asym"), -contains(".Z"))
#Transform it to long format
Asym_data_long<-Asym_data %>%
                    gather(key, asymmetry_index, -ID, -DAT1_3UTR) %>%
                    na.omit()

#Plot density plots before outlier removal
ggplot(Asym_data_long, aes(asymmetry_index))  + geom_density() + facet_wrap(~ key, scales="free")

#Calculate Z scores inside measure type
#####Z-score each participant's asymmetry_index inside key ####
#calculate mean and sd 
m <- tapply(Asym_data_long$asymmetry_index,Asym_data_long$key,mean, na.rm = T)
s <- sqrt(tapply(Asym_data_long$asymmetry_index,Asym_data_long$key,var, na.rm = T))
#calculate asymmetry_index.Z and save it inside Asym_data_long
Asym_data_long$asymmetry_index.Z <- (Asym_data_long$asymmetry_index-m[Asym_data_long$key])/s[Asym_data_long$key]

#Remove trials where absolute asymmetry_index.Z>3 (i.e. remove outlier RTs)
Asym_data_long<-Asym_data_long[!abs(Asym_data_long$asymmetry_index.Z)>3,]

#Plot density plots again after outlier removal
ggplot(Asym_data_long, aes(asymmetry_index))  + geom_density() + facet_wrap(~ key, scales="free")


Asym_data_wide<-Asym_data_long %>% select(., -asymmetry_index.Z)  %>% 
                    spread(key, asymmetry_index) 


lapply(dplyr::select(Asym_data_wide, contains("_LI_"), contains("Asym"), -contains(".Z")), function(x) t.test(x ~ Asym_data_wide$DAT1_3UTR, na.action=na.omit))


t_test_results<-as.data.frame(sapply(dplyr::select(Asym_data_wide, contains("_LI_"), contains("Asym"), -contains(".Z")), function(x) t.test(x ~ Asym_data_wide$DAT1_3UTR, na.action=na.omit)))


t_test_results<-t_test_results %>% tibble::rownames_to_column(.) %>%
  gather(var, val, - rowname) %>%
  spread(rowname, val)



detach("package:dplyr", unload=TRUE)
library(plyr)
```


###So the above ^ shows that there AD_LI_SLF1 is the only asymmetry measure with significant relationship with DAT1 genotype

#Test relationship between N2_Asym, CPP_Asym, RT_Asym and SLF (SLF I, II add III) Asym

```{r, echo=FALSE, warning=FALSE}

##Now grab only the Asym/lateralistion index (_LI_) measures 
data_for_cor<-dplyr::select(Asym_data_wide, -ID, -DAT1_3UTR)

##Re order the columns
data_for_cor <- dplyr::select(data_for_cor, RT_Asym, N2c_Asym, N2c_latency_Asym, N2i_Asym, N2i_latency_Asym, CPPonset_Asym, CPPslope_Asym, AD_LI_SLF1, AD_LI_SLF2 ,AD_LI_SLF3,FA_LI_SLF1,FA_LI_SLF2,FA_LI_SLF3,MD_LI_SLF1,MD_LI_SLF2,MD_LI_SLF3,RD_LI_SLF1,RD_LI_SLF2,RD_LI_SLF3,VOL_LI_SLF1,VOL_LI_SLF2,VOL_LI_SLF3)

##look at r-values, p-palues, and CIs  
print(corr.test(data_for_cor, method="pearson", adjust="none", alpha=.05,ci=TRUE),short=F)

cor_pram_list<-corr.test(data_for_cor, method="pearson", adjust="none", alpha=.05,ci=TRUE)

cor_pvalues<-as.data.frame(cor_pram_list$p)

#######################################
##Plot p-value matrix using ggplot:
png("P_values less than 05 uncorrected.png",  width = 10*600, height = 10*600, units = "px", res = 600)
p_data<-melt(as.matrix(cor_pvalues))
p_data<-rename(p_data, c("value"="p_value"))
p_data<-dplyr::mutate(p_data, p_value = replace(p_value, p_value>.05, NA)) #only plot uncorected p-values less than .04
####Plot:
qplot(x=Var1, y=Var2, data=p_data, fill=p_value, geom="tile")+
    theme(axis.title.x = element_text(face="bold", size=9),
          axis.text.x  = element_text(face="bold", angle=-90,  size=9)) +
    theme(axis.title.y = element_text(face="bold", size=9),
          axis.text.y  = element_text(angle=0, vjust=0.5, size=9))
dev.off()
#######################################


cor_pvalues<-as.data.frame(cor_pram_list$p)
cor_pvalues<-cor_pvalues %>% tibble::rownames_to_column(.) %>%
  gather(var, val, - rowname) %>%
  spread(rowname, val)

#Make correlation matrix for corPlot()
cor_matrix<-cor(as.matrix(data_for_cor), use="na.or.complete")

#Save the corPlot() as a .png image
png("Correlation betweem RT_Asymmetry & SLF_Asymmetry.png",  width = 10*600, height = 10*600, units = "px", res = 600)
corPlot(cor_matrix, numbers=T, main="Correlation betweem RT_Asymmetry & SLF_Asymmetry",  show.legend=F, upper=T,  cex = 1)
dev.off()
corPlot(cor_matrix, numbers=T, main="Correlation betweem RT_Asymmetry & SLF_Asymmetry",  show.legend=F, upper=T,  cex = 1)

#Scatter plot of the only significant relationship with RT_asym
png("scatter plot of RT_Asym vs AD_LI_SLF1.png",  width = 10*300, height = 10*300, units = "px", res = 600)
ggplot(data_for_cor, aes(x=RT_Asym, y=AD_LI_SLF1)) +
    geom_point(shape=1) +    # Use hollow circles
    geom_smooth(method=lm,   # Add linear regression line
                se=FALSE)    # Don't add shaded confidence region
dev.off()

p1<-ggplot(data_for_cor, aes(x=RT_Asym, y=AD_LI_SLF1)) +
    geom_point(shape=1) +    # Use hollow circles
    geom_smooth(method=lm,   # Add linear regression line
                se=FALSE)    # Don't add shaded confidence region

p2<-ggplot(data_for_cor, aes(x=RT_Asym, y=N2c_latency_Asym)) +
    geom_point(shape=1) +    # Use hollow circles
    geom_smooth(method=lm,   # Add linear regression line
                se=FALSE)    # Don't add shaded confidence region
				
				

p3<-ggplot(data_for_cor, aes(x=N2c_Asym, y=VOL_LI_SLF1)) +
    geom_point(shape=1) +    # Use hollow circles
    geom_smooth(method=lm,   # Add linear regression line
                se=FALSE)    # Don't add shaded confidence region
				
				
p4<-ggplot(data_for_cor, aes(x=N2c_Asym, y=MD_LI_SLF1)) +
    geom_point(shape=1) +    # Use hollow circles
    geom_smooth(method=lm,   # Add linear regression line
                se=FALSE)    # Don't add shaded confidence region
				
				

p5<-ggplot(data_for_cor, aes(x=N2c_Asym, y=CPPonset_Asym)) +
    geom_point(shape=1) +    # Use hollow circles
    geom_smooth(method=lm,   # Add linear regression line
                se=FALSE)    # Don't add shaded confidence region
				
				
p6<-ggplot(data_for_cor, aes(x=CPPslope_Asym, y=VOL_LI_SLF2)) +
    geom_point(shape=1) +    # Use hollow circles
    geom_smooth(method=lm,   # Add linear regression line
                se=FALSE)    # Don't add shaded confidence region
				
				
p7<-ggplot(data_for_cor, aes(x=CPPonset_Asym, y=FA_LI_SLF2)) +
    geom_point(shape=1) +    # Use hollow circles
    geom_smooth(method=lm,   # Add linear regression line
                se=FALSE)    # Don't add shaded confidence region

p8<-ggplot(data_for_cor, aes(x=N2c_Asym, y=AD_LI_SLF2)) +
    geom_point(shape=1) +    # Use hollow circles
    geom_smooth(method=lm,   # Add linear regression line
                se=FALSE)    # Don't add shaded confidence region
				
				
p9<-ggplot(data_for_cor, aes(x=RT_Asym, y=CPPonset_Asym)) +
    geom_point(shape=1) +    # Use hollow circles
    geom_smooth(method=lm,   # Add linear regression line
                se=FALSE)    # Don't add shaded confidence region
				

png("Some Scatter Plots.png",  width = 10*300, height = 10*300, units = "px", res = 600)				
source("multiplot.R")				
multiplot(p1,p2,p3,p4,p5,p6,p7,p8,p9, cols=3)
dev.off()


# plot(data_for_cor[,c(1:10)])


#Make histograms of all asymmetry_indexes
hist_data<-tidyr::gather(data_for_cor, measure, asymmetry_index, na.rm = T, convert = T, factor_key = T)
png("histograms of all asymmetry_indexes.png",  width = 10*600, height = 10*600, units = "px", res = 600)
ggplot(hist_data, aes(asymmetry_index))  + geom_histogram() + facet_wrap(~ measure, scales="free")
dev.off()
ggplot(hist_data, aes(asymmetry_index))  + geom_histogram() + facet_wrap(~ measure, scales="free")
ggplot(hist_data, aes(asymmetry_index))  + geom_density() + facet_wrap(~ measure, scales="free")

```

#Look at the effect of Hemifield on RT, regardless of DAT1 genotype 
```{r, echo=FALSE, warning=FALSE}
RT_random_effects_only<-lmer(log(RT) ~ 1 + (Hemifield | ID) +(1|ITI) + (1|Trial), data = data, REML=FALSE, na.action = na.omit)
RT_Hemifield<-update(RT_random_effects_only, .~. + Hemifield)
RT_TOT<-update(RT_Hemifield, .~. + Trial)
RT_Hemifield_by_TOT<-update(RT_TOT, .~. + Hemifield:Trial)
anova(RT_random_effects_only, RT_Hemifield, RT_Hemifield_by_TOT)


source("summarySE.R") 
source("summarySEwithin.R") #function to calculate Std.Er of mean
source("normDataWithin.R")
plotdata <- summarySEwithin(data, measurevar="RT", withinvars=c("Hemifield"), idvar="ID")
ggplot(plotdata, aes(x=Hemifield, y=RT, fill=Hemifield)) +
    geom_bar(position=position_dodge(.9), colour="Black", stat="identity") + 
    geom_errorbar(position=position_dodge(.9), width=.3, aes(ymin=RT-ci, ymax=RT+ci)) + #can change "se" to "ci" if I want to use 95%ci instead
    geom_hline(yintercept=0) +  coord_cartesian(ylim = c(400, 600)) +
    xlab("Hemifield") + ylab("RT (ms)") +
    theme(axis.title.x = element_text(face="bold", size=12),
          axis.text.x  = element_text(face="bold", angle=0,  size=12)) +
    theme(axis.title.y = element_text(face="bold", size=12),
          axis.text.y  = element_text(angle=0, vjust=0.5, size=12)) +
    theme(legend.title = element_text(size=11, face="bold")) +
    theme(legend.text = element_text(size = 11, face = "bold")) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
          panel.background = element_blank(), axis.line = element_line(colour = "black")) 



# 
# #Look at a boxplot of log(RT)
# ggplot(data, aes(Hemifield, log(RT), colour = Hemifield))  + 
#     geom_boxplot() + coord_flip() + theme_bw ()


#Plot the effect of Hemifield*Time-on-task
ggplot(data, aes(x=data$Trial, y=data$RT,fill=Hemifield,colour=Hemifield)) +
     # stat_smooth(method="glm",level = 0.95,size=1) + # Add a glm smoothed fit curve with 95% confidence region around the three light conditions
    geom_smooth() +
    scale_fill_manual(name="Target\nHemifield",  breaks=c("Left", "Right"), labels=c(" Left", " Right"), guide = guide_legend(reverse=TRUE), values=c("#999999", "black")) +
    scale_colour_manual(name="Target\nHemifield",  breaks=c("Left", "Right"), labels=c(" Left", " Right"), guide = guide_legend(reverse=TRUE), values=c("black", "black")) +
    ylab("RT (ms)") +  xlab("Time On Task (trials)") + coord_cartesian(ylim = c(500, 700))+
    theme(axis.title.x = element_text(face="bold", size=14),
          axis.text.x  = element_text(face="bold", angle=0,  size=12)) +
    theme(axis.title.y = element_text(face="bold", size=14),
          axis.text.y  = element_text(angle=0, vjust=0.5, size=12)) +
    theme(legend.title = element_text(size=14, face="bold")) +
    theme(legend.text = element_text(size = 12, face = "bold")) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
    panel.background = element_blank(), axis.line = element_line(colour = "black")) 

##Check the plot of the model parameters matches with this^ plot of the raw data 
# require(effects)
# plot(allEffects(RT_Hemifield_by_TOT), multiline=T)


```

**So this ^ shows that regardless of DAT1 genotype, participants tended to react faster to left hemifield targets, but this leftward advangate decreased over time**

#Check for difference in behavioural accuracy between 10_10_repeat and non10_10_repeat participants?
```{r, echo=FALSE, warning=FALSE}
data2<-data[complete.cases(data$DAT1_3UTR),]####### 


Accuracy_collapsed<-ddply(data2, .(ID, DAT1_3UTR), summarise, Accuracy=mean(Accuracy_overall))
###Check for Accuracy_overall outliers
min(Accuracy_collapsed$Accuracy)
#Plot the Accuracy distribution for each DAT1_3UTR
ggplot(Accuracy_collapsed, aes(Accuracy))  + geom_histogram() + facet_wrap(~ DAT1_3UTR)

############ Are there significant accuracy differences between 10_10_repeat and non10_10_repeat? ##############
##############################################################
#Overall Accuracy by DAT1_3UTR
log <- capture.output({
   Accuracy_DAT1_3UTR <- ezPerm(data = Accuracy_collapsed
                                  , dv = .(Accuracy)
                                  , wid = .(ID)
                                  , between = .(DAT1_3UTR)
                                  , perms = 1000);
 })
print("Factorial Permutation test for the effect of DAT1_3UTR on Accuracy:")
print(Accuracy_DAT1_3UTR);
```

**So this ^ shows shows no significant difference in accuracy between the DAT1 genotype groups** 

#Simple effects of Genotype inside each DAT1 Group show that non10_10_repeat participants have significant leftward RT asymmetry, and the 10_10_repeat participants do not
```{r, echo=FALSE, warning=FALSE}
#Calculate the number of trials each participant has left after NAs are kicked out:
num_trials2 <- ddply(data2, c("ID"), summarise,
               Num_RT_Trials    = length(RT))

summary(num_trials2)


#So get participant level RT into long format so I can run permutated t-tests  
RT_collapsed<-ddply(data2, .(ID, Hemifield, DAT1_3UTR, Site, DAT1_10_10_repeats), summarise, RT=mean(RT))

#Plot RT by DAT1_3UTR and hemifield:
RT_collapsed$DAT1_3UTR_by_Hemifield<-interaction(RT_collapsed$Hemifield, RT_collapsed$DAT1_3UTR)
#non log transformed:
ggplot(RT_collapsed, aes(RT))  + geom_histogram() + facet_wrap(~ DAT1_3UTR_by_Hemifield)
ggplot(RT_collapsed, aes(log(RT)))  + geom_histogram() + facet_wrap(~ DAT1_3UTR_by_Hemifield)


ggplot(RT_collapsed, aes(DAT1_3UTR_by_Hemifield, RT, colour = DAT1_3UTR_by_Hemifield))  + 
    geom_violin() + coord_flip() + theme_bw () +  geom_boxplot()


RT_collapsed$log_RT<-log(RT_collapsed$RT)


## 2 seperate permutated within subjects test for the effect of Hemifield##
#non10_10_repeat:
log <- capture.output({
RT_Hemifield_non10_10_repeat <- ezPerm(data = dplyr::filter(RT_collapsed, DAT1_3UTR=="non10_10_repeat")
                                  , dv = .(RT)
                                  , wid = .(ID)
                                  , within = .(Hemifield)
                                  , perms = 1000
) })
print("Factorial Permutation test for the simple effect of Target Hemifield on RT in the non10_10_repeat group:")
print(RT_Hemifield_non10_10_repeat)



#10_10_repeat:
log <- capture.output({
RT_Hemifield_10_10_repeat <- ezPerm(data = dplyr::filter(RT_collapsed, DAT1_3UTR=="10_10_repeat")
                                  , dv = .(RT)
                                  , wid = .(ID)
                                  , within = .(Hemifield)
                                  , perms = 1000
)})
print("Factorial Permutation test for the simple effect of Target Hemifield on RT in the 10_10_repeat group:")
print(RT_Hemifield_10_10_repeat)



```


###However, the difference the DAT1Group x Hemifield interaction in RT is not significant, and also there is no significant difference in RT-asymmetry between the 10_10_repeat and non10_10_repeat DAT1_3UTRs:

```{r, echo=FALSE, warning=FALSE}
log <- capture.output({
RT_Hemifield_by_DAT1_3UTR <- ezPerm(data = RT_collapsed
                                  , dv = .(RT)
                                  , wid = .(ID)
                                  , within = .(Hemifield)
                                  , between = .(DAT1_10_10_repeats)
                                  , perms = 1000
)})
print("Factorial Permutation test for Hemifield x DAT1 group interaction on RT:")
print(RT_Hemifield_by_DAT1_3UTR)



##Try the old school approach used in SPSS
ezANOVA(
    data = RT_collapsed
    , dv = .(log_RT)
    , wid = .(ID)
    , within = .(Hemifield)
    , between = .(DAT1_3UTR)
    , observed = .(DAT1_3UTR)
    , between_covariates = .(Site)
    , type = 3
    , detailed = F
)



######Calculate RT asymmetry Index and add it to "data_participant_level"######
#Collapse each participant's trials accross ITI
RT_collapsed<-ddply(data2, .(ID, Hemifield, DAT1_3UTR), summarise, RT=mean(RT))
#Bring Target-Hemifield up into wide format
RT_collapsed <- dcast(RT_collapsed, ID  ~ Hemifield, value.var="RT", fun.aggregate=mean)
RT_collapsed<-rename(RT_collapsed, c("Left"="RT_Left", "Right"="RT_Right"))
#Calculate RT asymmetry
RT_collapsed$RT_Asym<-(RT_collapsed$RT_Left-RT_collapsed$RT_Right)/(RT_collapsed$RT_Left+RT_collapsed$RT_Right)
RT_collapsed<-merge(RT_collapsed, DAT1, by.x = "ID", by.y = "ID") 

##################################################################################
ggplot(RT_collapsed, aes(RT_Asym))  + geom_histogram(aes(y=..count..), colour="black", fill="white") + facet_wrap(~ DAT1_3UTR)
#Try a density plot
ggplot(RT_collapsed, aes(RT_Asym, colour = DAT1_3UTR))  + 
    geom_density(alpha = 0.1) 

#Remove outliers
RT_collapsed$RT_Asym.Z<-scale(RT_collapsed$RT_Asym)
RT_collapsed<-RT_collapsed[abs(RT_collapsed$RT_Asym.Z)<3,]
#Try a density plot after outlier remove
ggplot(RT_collapsed, aes(RT_Asym, colour = DAT1_3UTR))  + 
    geom_density(alpha = 0.1) 

RT_Asym.mean <- ddply(RT_collapsed, "DAT1_3UTR", summarise, RT_Asym.mean=mean(RT_Asym))
RT_Asym.mean
##Between DAT1_3UTRs t-test for RT_Asym
t.test(RT_collapsed$RT_Asym ~ RT_collapsed$DAT1_3UTR)

##Try permutated t-test
log <- capture.output({
RTasym_DAT1_3UTR <- ezPerm(data = RT_collapsed
                                  , dv = .(RT_Asym)
                                  , wid = .(ID)
                                  , between = .(DAT1_3UTR)
                                  , perms = 1000
)})
print("Factorial Permutation test for effect if DAT1 group RT Asymmetry:")
print(RTasym_DAT1_3UTR)

```


#Try linear mixed model approach to test the DAT1_3UTR x Hemifield effect on log(RTs) in the single trial data:

```{r, echo=FALSE, warning=FALSE}

# #Look at a boxplot of RT
ggplot(data2, aes(Hemifield, RT, colour = Hemifield))  + 
    geom_violin() + coord_flip() + theme_bw () + facet_wrap(~ DAT1_10_10_repeats) +  geom_boxplot()


ggplot(data2, aes(Hemifield, RT, colour = Hemifield))  + 
    geom_violin() + coord_flip() + theme_bw () +  geom_boxplot() + facet_wrap(~ DAT1_3UTR)

data2$Hemifield_by_DAT1_3UTR<-interaction(data2$Hemifield, data2$DAT1_3UTR)
ggplot(data2, aes(Hemifield_by_DAT1_3UTR, RT, colour = Hemifield_by_DAT1_3UTR))  + 
    geom_violin() + coord_flip() + theme_bw () +  geom_boxplot() + facet_wrap(~ Site)

########################### Multi-level Models ########################## 
RT_random_intercepts_only<-lmer(log(RT) ~ 1 + (Hemifield | ID) +(1|ITI) + (1|Trial), data = data2, REML=FALSE, na.action = na.omit)
RT_DAT1_3UTR<-update(RT_random_intercepts_only, .~. + DAT1_3UTR)
RT_Hemifield<-update(RT_DAT1_3UTR, .~. + Hemifield)
RT_HemifieldbyDAT1_3UTR<-update(RT_Hemifield, .~. + Hemifield:DAT1_3UTR)
anova(RT_random_intercepts_only, RT_DAT1_3UTR, RT_Hemifield, RT_HemifieldbyDAT1_3UTR)

RT_random_intercepts_only<-lmer(log(RT) ~ 1 + (1 | Site/DAT1_3UTR/ID) +(1|ITI) + (1|Trial), data = data2, REML=FALSE, na.action = na.omit)
RT_DAT1_3UTR<-update(RT_random_intercepts_only, .~. + DAT1_3UTR)
RT_Hemifield<-update(RT_DAT1_3UTR, .~. + Hemifield)
RT_HemifieldbyDAT1_3UTR<-update(RT_Hemifield, .~. + Hemifield:DAT1_3UTR)
anova(RT_random_intercepts_only, RT_DAT1_3UTR, RT_Hemifield, RT_HemifieldbyDAT1_3UTR)


source("summarySE.R") 
source("summarySEwithin.R") #function to calculate Std.Er of mean
source("normDataWithin.R")
plotdata <- summarySEwithin(data, measurevar="RT", withinvars=c("Hemifield"), betweenvars=c("DAT1_3UTR"), idvar="ID")
ggplot(plotdata, aes(x=Hemifield, y=RT, fill=Hemifield)) +
    geom_bar(position=position_dodge(.9), colour="Black", stat="identity") + 
    geom_errorbar(position=position_dodge(.9), width=.3, aes(ymin=RT-ci, ymax=RT+ci)) + #can change "se" to "ci" if I want to use 95%ci instead
    geom_hline(yintercept=0) +  coord_cartesian(ylim = c(400, 600)) +
    xlab("Hemifield") + ylab("RT (ms)") +
    theme(axis.title.x = element_text(face="bold", size=12),
          axis.text.x  = element_text(face="bold", angle=0,  size=12)) +
    theme(axis.title.y = element_text(face="bold", size=12),
          axis.text.y  = element_text(angle=0, vjust=0.5, size=12)) +
    theme(legend.title = element_text(size=11, face="bold")) +
    theme(legend.text = element_text(size = 11, face = "bold")) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
          panel.background = element_blank(), axis.line = element_line(colour = "black")) + facet_wrap(~DAT1_3UTR) 



# RT_random_intercepts_only<-glmer(log(RT) ~ 1 + (Hemifield | ID) +(1|ITI) + (1|Trial), data = data2, family = Gamma(link = log) , na.action = na.omit)
# RT_DAT1_3UTR<-update(RT_random_intercepts_only, .~. + DAT1_3UTR)
# RT_Hemifield<-update(RT_DAT1_3UTR, .~. + Hemifield)
# RT_HemifieldbyDAT1_3UTR<-update(RT_Hemifield, .~. + Hemifield:DAT1_3UTR)
# anova(RT_random_intercepts_only, RT_DAT1_3UTR, RT_Hemifield, RT_HemifieldbyDAT1_3UTR)

# require(LMERConvenienceFunctions)
#   data2 <- romr.fnc(RT_HemifieldbyDAT1_3UTR, data2, trim = 3)
#   data2$n.removed
#   data2$percent.removed
#   data2<-data2$data

```

**So the linear mixed model approach ^ shows no significant DAT1_3UTR x Hemifield effect**

##However simple effects of hemifield inside DAT1_3UTR linear mixed model approach confirms that non10_10_repeat participants have signficantly faster RTs to left targets and 10_10_repeat participants do not: 
```{r, echo=FALSE, warning=FALSE}
#########Break down the signifiant Hemifield by DAT1_3UTR interaction:
#look at the effect of Hemifield for 10_10_repeat only  -
summary(glht(lmer(log(RT) ~ Hemifield + (Hemifield|Site/ID)+(1|ITI) + (1|Hemifield)+ (1|Trial), data = data2[data2$DAT1_3UTR=="10_10_repeat",], REML=FALSE, na.action = na.omit)))
#look at the effect of Hemifield for non10_10_repeat only - 
summary(glht(lmer(log(RT) ~ Hemifield + (Hemifield|Site/ID)+(1|ITI) + (1|Hemifield)+ (1|Trial), data = data2[data2$DAT1_3UTR=="non10_10_repeat",], REML=FALSE, na.action = na.omit)))

```

###So non10_10_repeat have significant pseudoneglect (i.e. faster RTs to left hemifield targets), and 10_10_repeat do not, but this is only seen in the simple effects (doing seperate test for each DAT1_3UTR). The factorial design gives no significant DAT1_3UTR x Hemifield effect



##Look at the DAT1Group x Hemifield x Time-on-task interaction in the single trial data:
```{r, echo=FALSE, warning=FALSE}

RT_random_effects_only<-lmer(log(RT) ~ 1 + (1 | ID) +(1|ITI) + (1|Trial), data = data2, REML=FALSE, na.action = na.omit)
RT_Hemifield<-update(RT_random_effects_only, .~. + Hemifield)
RT_DAT1<-update(RT_Hemifield, .~. + DAT1_3UTR)
RT_TOT<-update(RT_DAT1, .~. + Trial)
RT_Hemifield_by_DAT1<-update(RT_TOT, .~. + Hemifield:DAT1_3UTR)
RT_Hemifield_by_TOT<-update(RT_Hemifield_by_DAT1, .~. + Hemifield:Trial)
RT_DAT1_by_TOT<-update(RT_Hemifield_by_TOT, .~. + DAT1_3UTR:Trial)
RT_Hemifield_by_DAT1_by_TOT<-update(RT_DAT1_by_TOT, .~. + Hemifield:DAT1_3UTR:Trial)
anova(RT_random_effects_only, RT_Hemifield, RT_DAT1,RT_TOT, RT_Hemifield_by_DAT1, RT_Hemifield_by_TOT,RT_DAT1_by_TOT,RT_Hemifield_by_DAT1_by_TOT)



#Plot the effect of Hemifield*Time-on-task
ggplot(data2, aes(x=data2$Trial, y=data2$RT,fill=Hemifield,colour=Hemifield)) +
     # stat_smooth(method="glm",level = 0.95,size=1) + # Add a glm smoothed fit curve with 95% confidence region around the three light conditions
    geom_smooth() +
    scale_fill_manual(name="Target\nHemifield",  breaks=c("Left", "Right"), labels=c(" Left", " Right"), guide = guide_legend(reverse=TRUE), values=c("#999999", "black")) +
    scale_colour_manual(name="Target\nHemifield",  breaks=c("Left", "Right"), labels=c(" Left", " Right"), guide = guide_legend(reverse=TRUE), values=c("black", "black")) +
    ylab("RT (ms)") +  xlab("Time On Task (trials)") + coord_cartesian(ylim = c(500, 650))+
    theme(axis.title.x = element_text(face="bold", size=14),
          axis.text.x  = element_text(face="bold", angle=0,  size=12)) +
    theme(axis.title.y = element_text(face="bold", size=14),
          axis.text.y  = element_text(angle=0, vjust=0.5, size=12)) +
    theme(legend.title = element_text(size=14, face="bold")) +
    theme(legend.text = element_text(size = 12, face = "bold")) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
    panel.background = element_blank(), axis.line = element_line(colour = "black")) + facet_wrap(~ DAT1_3UTR)


```

###So there is no evidence for a 3-way DAT1Group x Hemifield x Time-on-task interaction. I haven't included random slopes directly above, so if there was any hint on a 3-way DAT1Group x Hemifield x Time-on-task interaction this model should have detected it!
